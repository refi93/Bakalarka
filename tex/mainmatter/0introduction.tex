\chapter*{Úvod}
\addcontentsline{toc}{chapter}{Úvod}  
\paragraph{}
Konečné automaty majú uplatnenie vo viacerých oblastiach informatiky, napríklad pri lexikálnej analýze, hľadaní výskytov reťazcov v texte, vytváraní jednoduchých stratégii a určite by sa našli aj ďalšie.

Je známe, že hoci výpočtová sila deterministických konečných automatov (DKA) je ekvivalentná výpočtovej sile nedeterministických konečných automatov (NKA), minimálny DKA môže vzhľadom na ekvivalentný minimálny NKA mať potenciálne až $2^n$ stavov, kde $n$ je počet stavov pôvodného NKA. Pomerne často sa ale môžeme stretnúť s prípadmi, kedy je tento nárast značne menší.

Výhodou NKA, ako sme vyššie spomínali, je menší počet stavov a jednoduchší návrh, keďže tam nie sú také striktné požiadavky. Na druhú stranu, DKA sa jednoduchšie implementujú, keďže to lepšie zodpovedá spôsobu, akým fungujú súčasné počítače a v konečnom dôsledku aj väčšina programovacích jazykov. Preto, a nielen preto, by nás mohlo zaujímať, aké je to v skutočnosti ,,zlé'' alebo ,,dobré'' s tým počtom stavov pri DKA. 

Zistiť to pre všetky možné automaty sa javí byť mimoriadne náročná úloha. Ak sa vyberieme cestou priamočiareho generovania všetkých možných NKA, už pre pomerne malú abecedu a zopár stavov ich existuje veľmi veľa. Naším cieľom bude tento nárast počtu stavov v priemernom prípade experimentálne odmerať aspoň pre NKA do 4-5 stavov nad binárnou abecedou, prípadne pokúsiť sa nahliadnuť ako to vyzerá pri unárnej alebo trojznakovej abecede.

Druhá, nemenej zaujímavá, otázka, na ktorú sa pokúsime odpovedať bude, koľko jedinečných regulárnych jazykov sú schopné akceptovať nedeterministické automaty ohraničené malým počtom stavov nad malou abecedou. Bude to jeden z výsledkov, ktorý vyplynie zo spôsobu, akým budeme náš experiment vykonávať.

Nie sme prví, ktorí sa snažia tieto otázky zodpovedať. V minulosti sa tým zaoberali napr. v článku \cite{shallit}. Ich výsledky pokryli NKA do 3 stavov. My sa pokúsime ísť trocha ďalej a zistiť to pre viac stavov, čo by nám mohlo poskytnúť lepší náhľad, ako to môže byť vo všeobecnosti. Najväčšou výzvou bude navrhnúť algoritmus, ktorý bude schopný skutočne overiť všetky možnosti na súčasnom hardvéri.


